import Journey from "../models/journey.mjs";
import Task from "../models/task.mjs";
import User from "../models/user.mjs";
import jwt from "jsonwebtoken";
import { generateJourneyWithAI } from '../services/aiService.mjs';

// Helper: generate mock tasks for a journey
function generateMockTasks(goal, startDate, userId, journeyId) {
  const baseDate = new Date(startDate);
  const descriptions = [
    `Write down your top 3 goals for ${goal}.`,
    `Reflect on a recent challenge related to ${goal}.`,
    `Read a chapter from a book about ${goal}.`,
    `Practice 10 minutes of mindfulness meditation.`,
    `Reach out to a mentor or peer for advice.`,
    `Set a new micro-habit for the week.`,
    `Review your progress and journal your thoughts.`,
  ];
  return descriptions.map((desc, i) => ({
    journeyId,
    userId,
    day: i + 1,
    description: desc,
    dueDate: new Date(baseDate.getTime() + i * 24 * 60 * 60 * 1000),
    status: 'pending',
  }));
}

export const generateJourney = async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ message: "No token provided" });
    }
    const token = authHeader.split(" ")[1];
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const userId = decoded.id;

    // Use onboarding data from request or user profile
    const onboardingData = req.body;
    let aiResult;
    try {
      aiResult = await generateJourneyWithAI(onboardingData);
      // Validate AI result structure
      if (!aiResult || !Array.isArray(aiResult.tasks) || aiResult.tasks.length === 0) {
        throw new Error('AI did not return valid tasks');
      }
    } catch (err) {
      console.error("AI generation failed, falling back to mock tasks:", err);
      aiResult = { goal: onboardingData.goal || 'Personal Development', tasks: generateMockTasks(onboardingData.goal || 'Personal Development', onboardingData.startDate || new Date().toISOString().slice(0, 10), userId, null).map(t => ({ description: t.description })) };
    }
    const { goal, tasks } = aiResult;
    const startDate = onboardingData.startDate || new Date().toISOString().slice(0, 10);

    // Only use up to 21 tasks, filter out invalid ones
    const validTasks = tasks
      .filter(t => t && typeof t.description === 'string' && t.description.trim().length > 0)
      .slice(0, 21);
    if (validTasks.length === 0) {
      return res.status(500).json({ message: 'No valid tasks generated by AI.' });
    }

    // Create journey
    const journey = await Journey.create({
      userId,
      goal,
      startDate,
      totalTasks: validTasks.length,
      completedTasks: 0,
      points: 0,
      status: 'active',
    });

    // Generate and create tasks
    const dbTasks = validTasks.map((t, i) => ({
      journeyId: journey.id,
      userId,
      day: i + 1,
      description: t.description,
      dueDate: new Date(new Date(startDate).getTime() + i * 24 * 60 * 60 * 1000),
      status: 'pending',
    }));
    try {
      await Task.bulkCreate(dbTasks);
    } catch (err) {
      console.error('Task bulkCreate error:', err, dbTasks);
      return res.status(500).json({ message: 'Failed to create tasks', error: err.message });
    }

    res.status(201).json({ message: 'Journey generated', journeyId: journey.id });
  } catch (error) {
    console.error("Generate journey error:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
};

export const getJourney = async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ message: "No token provided" });
    }
    const token = authHeader.split(" ")[1];
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const userId = decoded.id;

    // Get the user's active journey
    const journey = await Journey.findOne({
      where: { userId, status: 'active' },
      include: [{ model: Task, as: 'tasks' }],
      order: [[{ model: Task, as: 'tasks' }, 'day', 'ASC']],
    });
    if (!journey) {
      return res.status(404).json({ message: 'No active journey found' });
    }
    res.status(200).json({ journey });
  } catch (error) {
    console.error("Get journey error:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
};

export const completeTask = async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ message: "No token provided" });
    }
    const token = authHeader.split(" ")[1];
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const userId = decoded.id;
    const { id } = req.params;
    // Find the task
    const task = await Task.findOne({ where: { id, userId } });
    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }
    if (task.status === 'done') {
      return res.status(400).json({ message: "Task already completed" });
    }
    // Mark as done
    task.status = 'done';
    await task.save();
    // Update journey progress and points
    const journey = await Journey.findByPk(task.journeyId);
    if (journey) {
      journey.completedTasks += 1;
      journey.points += 40; // Award points per task
      // If all tasks done, mark journey as completed
      if (journey.completedTasks >= journey.totalTasks) {
        journey.status = 'completed';
      }
      await journey.save();
    }
    res.status(200).json({ message: 'Task marked as done', taskId: id });
  } catch (error) {
    console.error("Complete task error:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
};

export const skipTask = async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ message: "No token provided" });
    }
    const token = authHeader.split(" ")[1];
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const userId = decoded.id;
    const { id } = req.params;
    // Find the task
    const task = await Task.findOne({ where: { id, userId } });
    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }
    if (task.status === 'skipped') {
      return res.status(400).json({ message: "Task already skipped" });
    }
    // Mark as skipped
    task.status = 'skipped';
    await task.save();
    res.status(200).json({ message: 'Task skipped', taskId: id });
  } catch (error) {
    console.error("Skip task error:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
};

export const getLeaderboard = async (req, res) => {
  try {
    // Top users by journey points and completed tasks
    const users = await User.findAll({
      attributes: ['id', 'name'],
      include: [{
        model: Journey,
        as: 'journeys',
        attributes: ['points', 'completedTasks'],
      }],
    });
    // Aggregate points and completedTasks
    const leaderboard = users.map(user => {
      const journeys = user.journeys || [];
      const points = journeys.reduce((sum, j) => sum + (j.points || 0), 0);
      const milestones = journeys.reduce((sum, j) => sum + (j.completedTasks || 0), 0);
      return {
        name: user.name,
        points,
        milestones,
      };
    });
    // Sort by points desc, then milestones desc
    leaderboard.sort((a, b) => b.points - a.points || b.milestones - a.milestones);
    res.status(200).json({ leaderboard });
  } catch (error) {
    console.error("Leaderboard error:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
}; 